''' MRCV/block_DCT.py '''

import numpy as np
import deadzone as Q
import information
import distortion

def block_transform(block):
    '''(Forward) DCT block transform.'''
    return dct(block, norm="ortho")

def block_inverse_transform(block):
    '''Inverse DCT block transform.'''
    return idct(block, norm="ortho")

def image_transform(image, blocks_in_y, blocks_in_x):
    '''DCT image transform by blocks.'''
    for y in range(blocks_in_y):
        for x in range(blocks_in_x):
            block = image[y*block_y_side:(y+1)*block_y_side,
                          x*block_x_side:(x+1)*block_x_side]
            
            DCT_block = block_transform(block)
            image[y*block_y_side:(y+1)*block_y_side,
                          x*block_x_side:(x+1)*block_x_side] = block
    return image

def constant_quantization(image, q_step):
    '''Quantize all blocks of the DCT <image> with the same <q_step>.'''
    return Q.quantize(image, q_step)

def constant_dequantization(image, q_step):
    '''De-quantize all blocks of the DCT <image> with the same
<q_step>.'''
    return Q.quantize(image, q_step)

def optimal_quantization(image, blocks_in_y, blocks_in_x, q_step):
    '''Quantize the DCT <image> using a quantization step (to compute)
that generates approximately the same RD-slope for all the
blocks. First, the "master" <q_step> is used to quantize all the
coefficients and the mean RD-slope is computed. Then, those blocks
with smaller RD-slope increase their quantization step until this
condition is false, and viceversa.

    '''
    quantized_image = constant_quantization(image, q_step)
    slopes = np.array(shape=(blocks_in_y, blocks_in_x), dtype=np.float32)
    Q_steps = np.full(shape=(blocks_in_y, blocks_in_x), fill_value=q_step, dtype=np.uint8)
    for y in range(blocks_in_y):
        for x in range(blocks_in_x):
            block = image[y*block_y_side:(y+1)*block_y_side,
                          x*block_x_side:(x+1)*block_x_side]
            block_DCT = block_transform(block)
            # The RD-slope is computed considering the RD-point for
            # lossless coding and the RD-point generated by the
            # current cuantization step.
            RD_point_for_Q_step_one = (information.entropy(block_DCT.flatten().astype(np.int16)), 0)
            quantized_block_DCT = Q.quantize(block, q_step)
            dequantized_block_DCT = Q.dequantize(quantized_block_DCT, q_step)
            dequantized_block = inverse_block_transform(dequantized_block_DCT)
            # Notice that if the DCT is orthogonal, the distortion can
            # be also computed in the transform domain
            current_RD_point = (information.entropy(quantized_block_DCT.flatten()), distortion.MSE(block, dequantized_block))
            slopes[y,x] = current_RD_point[1] / (RD_point_for_Q_step_one[0] - current_RD_point[0])

        median_slope = np.median(block_slopes)

        # Adjust the quantization step of those blocks with a slope
        # different to <median_slope>
        for y in range(blocks_in_y):
            for x in range(blocks_in_x):
                while slopes[y,x] > median_slope:
                    new_Q_step = Q_steps[y,x] - 1
                    if new_Q_step >= 64:
                        break
                    block = image[y*block_y_side:(y+1)*block_y_side,
                                  x*block_x_side:(x+1)*block_x_side]
                    block_DCT = block_transform(block)
                    RD_point_for_Q_step_one = (information.entropy(block_DCT.flatten().astype(np.int16)), 0)
                    quantized_block_DCT = Q.quantize(block_DCT, new_Q_step)
                    dequantized_block_DCT = Q.dequantize(quantized_block_DCT, new_Q_step)
                    dequantized_block = inverse_block_transform(dequantized_block_DCT)
                    current_RD_point = (information.entropy(quantized_block_DCT.flatten()), distortion.MSE(block, dequantized_block))
                    current_slope = slopes[y,x]
                    slopes[y,x] = current_RD_point[1] / (RD_point_for_Q_step_one[0] - current_RD_point[0])
                    if current_slope == slopes[y,x]:
                        break
                    Q_steps[y,x] = new_Q_step

                while slopes[y,x] < median_slope:
                    new_Q_step = Q_steps[y,x] + 1
                    if new_Q_step <= 0:
                        break
                    block = image[y*block_y_side:(y+1)*block_y_side,
                                  x*block_x_side:(x+1)*block_x_side]
                    block_DCT = block_transform(block)
                    RD_point_for_Q_step_one = (information.entropy(block_DCT.flatten().astype(np.int16)), 0)
                    quantized_block_DCT = Q.quantize(block_DCT, new_Q_step)
                    dequantized_block_DCT = Q.dequantize(quantized_block_DCT, new_Q_step)
                    dequantized_block = inverse_block_transform(dequantized_block_DCT)
                    current_RD_point = (information.entropy(quantized_block_DCT.flatten()), distortion.MSE(block, dequantized_block))
                    current_slope = slopes[y,x]
                    slopes[y,x] = current_RD_point[1] / (RD_point_for_Q_step_one[0] - current_RD_point[0])
                    if current_slope == slopes[y,x]:
                        break
                    Q_steps[y,x] = new_Q_step

        # Quantize and dequantize the image (in the image domain) and
        # generated the quantization indexes (in the DCT domain)
        quantized_image_DCT = np.empty_like(image)
        for y in range(blocks_in_y):
            for x in range(blocks_in_x):
                block = image[y*block_y_side:(y+1)*block_y_side,
                              x*block_x_side:(x+1)*block_x_side]
                block_DCT = block_transform(block)
                quantized_block_DCT = Q.quantize(block_DCT, Q_steps[y,x])
                quantized_image_DCT[y*block_y_side:(y+1)*block_y_side,
                                    x*block_x_side:(x+1)*block_x_side] = quantized_block_DCT
                dequantized_block_DCT = Q.dequantize(quantized_block_DCT, Q_steps[y,x])
                dequantized_block = inverse_block_transform(dequantized_block_DCT)
                image[y*block_y_side:(y+1)*block_y_side,
                      x*block_x_side:(x+1)*block_x_side] = dequantized_block

        return image, quantized_image_DCT, Q_steps
